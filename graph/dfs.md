# Обход в глубину и его применение

Обход в глубину — один из способов обхода графа, который базируется на рекурсии. Идея заключается в следующем: на вход подается стартовая вершина 
графа, затем из каждой из вершин пустим рекурсию, предварительно проверив, была ли вершина уже посещена или нет.

Time complexity: O(N+M)

## Применение dfs в задачах
- Поиск любого пути в графе.
- Поиск лексикографически первого пути в графе.
- Проверка, является ли одна вершина дерева предком другой: В начале и конце итерации поиска в глубину будет запоминать "время" захода и выхода в каждой вершине. Теперь за O(1) можно найти ответ: вершина i является предком вершины j тогда и только тогда, когда starti < startj и endi > endj.
- Задача LCA (наименьший общий предок).
- Топологическая сортировка: Запускаем серию поисков в глубину, чтобы обойти все вершины графа. Отсортируем вершины по времени выхода по убыванию - это и будет ответом.
- Проверка графа на ацикличность и нахождение цикла
- Поиск компонент сильной связности: Сначала делаем топологическую сортировку, потом транспонируем граф и проводим снова серию поисков в глубину в порядке, определяемом топологической сортировкой. Каждое дерево поиска - сильносвязная компонента.
- Поиск мостов: Сначала превращаем граф в ориентированный, делая серию поисков в глубину, и ориентируя каждое ребро так, как мы пытались по нему пройти. Затем находим сильносвязные компоненты. Мостами являются те рёбра, концы которых принадлежат разным сильносвязным компонентам.


## Задачи
- Посчитать количество вершин в графе заданном в виде матрицы смежности isConnected[i][j]
- acmp
  - Определить является ли граф деревом
  - Покраска лабиринта
  - Грядки
- leetcode
  - All paths from source to target


```
public class Derevo {

   int n;
   int[][] g;
   boolean used[];
   int edges = 0;
   int count = 0;

   void dfs(int start) {
       if (used[start]) return;
       used[start] = true;
       for (int i=0; i<n; i++) {
           if (used[i]==false && g[start][i] > 0) {
               dfs(i);
               count++;
           }
       }
   }

   public void solve() {
       n = sc.nextInt();
       g = new int[n][n];
       used = new boolean[n];
       for (int i=0; i<n; i++) {
           for (int j=0; j<n; j++) {
               g[i][j] = sc.nextInt();
           }
       }
       dfs(0);
   }

   public static void main(String[] args) {
       new Derevo().solve();
   }
}
```
